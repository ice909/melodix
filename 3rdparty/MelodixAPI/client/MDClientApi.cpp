/**
 * MelodixAPI
 * Melodix API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "MDClientApi.h"
#include "MDServerConfiguration.h"
#include <QJsonArray>
#include <QJsonDocument>

namespace MelodixAPI {

MDClientApi::MDClientApi(const int timeOut)
    : _timeOut(timeOut),
      _manager(nullptr),
      _isResponseCompressionEnabled(false),
      _isRequestCompressionEnabled(false) {
    initializeServerConfigs();
}

MDClientApi::~MDClientApi() {
}

void MDClientApi::initializeServerConfigs() {
    //Default server
    QList<MDServerConfiguration> defaultConf = QList<MDServerConfiguration>();
    //varying endpoint server
    defaultConf.append(MDServerConfiguration(
    QUrl("http://81.70.119.233:4000/"),
    "No description provided",
    QMap<QString, MDServerVariable>()));
    _serverConfigs.insert("banner", defaultConf);
    _serverIndices.insert("banner", 0);
    _serverConfigs.insert("cellphoneLogin", defaultConf);
    _serverIndices.insert("cellphoneLogin", 0);
    _serverConfigs.insert("checkMusic", defaultConf);
    _serverIndices.insert("checkMusic", 0);
    _serverConfigs.insert("getAccountInfo", defaultConf);
    _serverIndices.insert("getAccountInfo", 0);
    _serverConfigs.insert("getArtistAlbum", defaultConf);
    _serverIndices.insert("getArtistAlbum", 0);
    _serverConfigs.insert("getArtistDetail", defaultConf);
    _serverIndices.insert("getArtistDetail", 0);
    _serverConfigs.insert("getArtistMv", defaultConf);
    _serverIndices.insert("getArtistMv", 0);
    _serverConfigs.insert("getArtistSingle", defaultConf);
    _serverIndices.insert("getArtistSingle", 0);
    _serverConfigs.insert("getArtistSublist", defaultConf);
    _serverIndices.insert("getArtistSublist", 0);
    _serverConfigs.insert("getHotComment", defaultConf);
    _serverIndices.insert("getHotComment", 0);
    _serverConfigs.insert("getLikeSongId", defaultConf);
    _serverIndices.insert("getLikeSongId", 0);
    _serverConfigs.insert("getLoginStatus", defaultConf);
    _serverIndices.insert("getLoginStatus", 0);
    _serverConfigs.insert("getLyric", defaultConf);
    _serverIndices.insert("getLyric", 0);
    _serverConfigs.insert("getMvDetail", defaultConf);
    _serverIndices.insert("getMvDetail", 0);
    _serverConfigs.insert("getMvSublist", defaultConf);
    _serverIndices.insert("getMvSublist", 0);
    _serverConfigs.insert("getMvUrl", defaultConf);
    _serverIndices.insert("getMvUrl", 0);
    _serverConfigs.insert("getPlaylistDetail", defaultConf);
    _serverIndices.insert("getPlaylistDetail", 0);
    _serverConfigs.insert("getPlaylistTrackAll", defaultConf);
    _serverIndices.insert("getPlaylistTrackAll", 0);
    _serverConfigs.insert("getPurchasedAlbum", defaultConf);
    _serverIndices.insert("getPurchasedAlbum", 0);
    _serverConfigs.insert("getQrKey", defaultConf);
    _serverIndices.insert("getQrKey", 0);
    _serverConfigs.insert("getRecommendedMv", defaultConf);
    _serverIndices.insert("getRecommendedMv", 0);
    _serverConfigs.insert("getRecommendedNewSongs", defaultConf);
    _serverIndices.insert("getRecommendedNewSongs", 0);
    _serverConfigs.insert("getRecommendedPlaylist", defaultConf);
    _serverIndices.insert("getRecommendedPlaylist", 0);
    _serverConfigs.insert("getSimiMv", defaultConf);
    _serverIndices.insert("getSimiMv", 0);
    _serverConfigs.insert("getSongDetail", defaultConf);
    _serverIndices.insert("getSongDetail", 0);
    _serverConfigs.insert("getSongUrl", defaultConf);
    _serverIndices.insert("getSongUrl", 0);
    _serverConfigs.insert("getTopArtists", defaultConf);
    _serverIndices.insert("getTopArtists", 0);
    _serverConfigs.insert("getTopPlaylist", defaultConf);
    _serverIndices.insert("getTopPlaylist", 0);
    _serverConfigs.insert("getUserPlaylist", defaultConf);
    _serverIndices.insert("getUserPlaylist", 0);
    _serverConfigs.insert("likeMusic", defaultConf);
    _serverIndices.insert("likeMusic", 0);
    _serverConfigs.insert("qrCheck", defaultConf);
    _serverIndices.insert("qrCheck", 0);
    _serverConfigs.insert("qrCreate", defaultConf);
    _serverIndices.insert("qrCreate", 0);
    _serverConfigs.insert("search", defaultConf);
    _serverIndices.insert("search", 0);
    _serverConfigs.insert("sendCaptcha", defaultConf);
    _serverIndices.insert("sendCaptcha", 0);
    _serverConfigs.insert("verifyCaptcha", defaultConf);
    _serverIndices.insert("verifyCaptcha", 0);
}

/**
* returns 0 on success and -1, -2 or -3 on failure.
* -1 when the variable does not exist and -2 if the value is not defined in the enum and -3 if the operation or server index is not found
*/
int MDClientApi::setDefaultServerValue(int serverIndex, const QString &operation, const QString &variable, const QString &value) {
    auto it = _serverConfigs.find(operation);
    if (it != _serverConfigs.end() && serverIndex < it.value().size()) {
      return _serverConfigs[operation][serverIndex].setDefaultValue(variable,value);
    }
    return -3;
}
void MDClientApi::setServerIndex(const QString &operation, int serverIndex) {
    if (_serverIndices.contains(operation) && serverIndex < _serverConfigs.find(operation).value().size()) {
        _serverIndices[operation] = serverIndex;
    }
}

void MDClientApi::setApiKey(const QString &apiKeyName, const QString &apiKey) {
    _apiKeys.insert(apiKeyName, apiKey);
}

void MDClientApi::setBearerToken(const QString &token) {
    _bearerToken = token;
}

void MDClientApi::setUsername(const QString &username) {
    _username = username;
}

void MDClientApi::setPassword(const QString &password) {
    _password = password;
}


void MDClientApi::setTimeOut(const int timeOut) {
    _timeOut = timeOut;
}

void MDClientApi::setWorkingDirectory(const QString &path) {
    _workingDirectory = path;
}

void MDClientApi::setNetworkAccessManager(QNetworkAccessManager* manager) {
    _manager = manager;
}

/**
    * Appends a new ServerConfiguration to the config map for a specific operation.
    * @param operation The id to the target operation.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    * returns the index of the new server config on success and -1 if the operation is not found
    */
int MDClientApi::addServerConfiguration(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, MDServerVariable> &variables) {
    if (_serverConfigs.contains(operation)) {
        _serverConfigs[operation].append(MDServerConfiguration(
                    url,
                    description,
                    variables));
        return _serverConfigs[operation].size()-1;
    } else {
        return -1;
    }
}

/**
    * Appends a new ServerConfiguration to the config map for a all operations and sets the index to that server.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void MDClientApi::setNewServerForAllOperations(const QUrl &url, const QString &description, const QMap<QString, MDServerVariable> &variables) {
#if QT_VERSION >= QT_VERSION_CHECK(5, 12, 0)
    for (auto keyIt = _serverIndices.keyBegin(); keyIt != _serverIndices.keyEnd(); keyIt++) {
        setServerIndex(*keyIt, addServerConfiguration(*keyIt, url, description, variables));
    }
#else
    for (auto &e : _serverIndices.keys()) {
        setServerIndex(e, addServerConfiguration(e, url, description, variables));
    }
#endif
}

/**
    * Appends a new ServerConfiguration to the config map for an operations and sets the index to that server.
    * @param URL A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void MDClientApi::setNewServer(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, MDServerVariable> &variables) {
    setServerIndex(operation, addServerConfiguration(operation, url, description, variables));
}

void MDClientApi::addHeaders(const QString &key, const QString &value) {
    _defaultHeaders.insert(key, value);
}

void MDClientApi::enableRequestCompression() {
    _isRequestCompressionEnabled = true;
}

void MDClientApi::enableResponseCompression() {
    _isResponseCompressionEnabled = true;
}

void MDClientApi::abortRequests() {
    emit abortRequestsSignal();
}

QString MDClientApi::getParamStylePrefix(const QString &style) {
    if (style == "matrix") {
        return ";";
    } else if (style == "label") {
        return ".";
    } else if (style == "form") {
        return "&";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "&";
    } else if (style == "pipeDelimited") {
        return "&";
    } else {
        return "none";
    }
}

QString MDClientApi::getParamStyleSuffix(const QString &style) {
    if (style == "matrix") {
        return "=";
    } else if (style == "label") {
        return "";
    } else if (style == "form") {
        return "=";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "=";
    } else if (style == "pipeDelimited") {
        return "=";
    } else {
        return "none";
    }
}

QString MDClientApi::getParamStyleDelimiter(const QString &style, const QString &name, bool isExplode) {

    if (style == "matrix") {
        return (isExplode) ? ";" + name + "=" : ",";

    } else if (style == "label") {
        return (isExplode) ? "." : ",";

    } else if (style == "form") {
        return (isExplode) ? "&" + name + "=" : ",";

    } else if (style == "simple") {
        return ",";
    } else if (style == "spaceDelimited") {
        return (isExplode) ? "&" + name + "=" : " ";

    } else if (style == "pipeDelimited") {
        return (isExplode) ? "&" + name + "=" : "|";

    } else if (style == "deepObject") {
        return (isExplode) ? "&" : "none";

    } else {
        return "none";
    }
}

void MDClientApi::banner(const ::MelodixAPI::OptionalParam<QString> &type) {
    QString fullPath = QString(_serverConfigs["banner"][_serverIndices.value("banner")].URL()+"/banner");
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (type.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "type", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("type")).append(querySuffix).append(QUrl::toPercentEncoding(::MelodixAPI::toStringValue(type.value())));
    }
    MDHttpRequestWorker *worker = new MDHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    MDHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &MDHttpRequestWorker::on_execution_finished, this, &MDClientApi::bannerCallback);
    connect(this, &MDClientApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<MDHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void MDClientApi::bannerCallback(MDHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    MDBanner_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit bannerSignal(output);
        emit bannerSignalFull(worker, output);
    } else {
        emit bannerSignalE(output, error_type, error_str);
        emit bannerSignalEFull(worker, error_type, error_str);
    }
}

void MDClientApi::cellphoneLogin(const QString &phone, const QString &password, const ::MelodixAPI::OptionalParam<QString> &captcha, const ::MelodixAPI::OptionalParam<QString> &countrycode, const ::MelodixAPI::OptionalParam<QString> &md5_password) {
    QString fullPath = QString(_serverConfigs["cellphoneLogin"][_serverIndices.value("cellphoneLogin")].URL()+"/login/cellphone");
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "phone", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("phone")).append(querySuffix).append(QUrl::toPercentEncoding(::MelodixAPI::toStringValue(phone)));
    }
    
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "password", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("password")).append(querySuffix).append(QUrl::toPercentEncoding(::MelodixAPI::toStringValue(password)));
    }
    if (captcha.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "captcha", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("captcha")).append(querySuffix).append(QUrl::toPercentEncoding(::MelodixAPI::toStringValue(captcha.value())));
    }
    if (countrycode.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "countrycode", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("countrycode")).append(querySuffix).append(QUrl::toPercentEncoding(::MelodixAPI::toStringValue(countrycode.value())));
    }
    if (md5_password.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "md5_password", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("md5_password")).append(querySuffix).append(QUrl::toPercentEncoding(::MelodixAPI::toStringValue(md5_password.value())));
    }
    MDHttpRequestWorker *worker = new MDHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    MDHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &MDHttpRequestWorker::on_execution_finished, this, &MDClientApi::cellphoneLoginCallback);
    connect(this, &MDClientApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<MDHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void MDClientApi::cellphoneLoginCallback(MDHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    MDCellphoneLogin_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit cellphoneLoginSignal(output);
        emit cellphoneLoginSignalFull(worker, output);
    } else {
        emit cellphoneLoginSignalE(output, error_type, error_str);
        emit cellphoneLoginSignalEFull(worker, error_type, error_str);
    }
}

void MDClientApi::checkMusic(const QString &id, const ::MelodixAPI::OptionalParam<QString> &br) {
    QString fullPath = QString(_serverConfigs["checkMusic"][_serverIndices.value("checkMusic")].URL()+"/check/music");
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "id", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("id")).append(querySuffix).append(QUrl::toPercentEncoding(::MelodixAPI::toStringValue(id)));
    }
    if (br.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "br", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("br")).append(querySuffix).append(QUrl::toPercentEncoding(::MelodixAPI::toStringValue(br.value())));
    }
    MDHttpRequestWorker *worker = new MDHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    MDHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &MDHttpRequestWorker::on_execution_finished, this, &MDClientApi::checkMusicCallback);
    connect(this, &MDClientApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<MDHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void MDClientApi::checkMusicCallback(MDHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    MDCheckMusic_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit checkMusicSignal(output);
        emit checkMusicSignalFull(worker, output);
    } else {
        emit checkMusicSignalE(output, error_type, error_str);
        emit checkMusicSignalEFull(worker, error_type, error_str);
    }
}

void MDClientApi::getAccountInfo(const double &timestamp) {
    QString fullPath = QString(_serverConfigs["getAccountInfo"][_serverIndices.value("getAccountInfo")].URL()+"/user/account");
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "timestamp", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("timestamp")).append(querySuffix).append(QUrl::toPercentEncoding(::MelodixAPI::toStringValue(timestamp)));
    }
    MDHttpRequestWorker *worker = new MDHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    MDHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &MDHttpRequestWorker::on_execution_finished, this, &MDClientApi::getAccountInfoCallback);
    connect(this, &MDClientApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<MDHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void MDClientApi::getAccountInfoCallback(MDHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    MDGetAccountInfo_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getAccountInfoSignal(output);
        emit getAccountInfoSignalFull(worker, output);
    } else {
        emit getAccountInfoSignalE(output, error_type, error_str);
        emit getAccountInfoSignalEFull(worker, error_type, error_str);
    }
}

void MDClientApi::getArtistAlbum(const QString &id, const ::MelodixAPI::OptionalParam<QString> &limit) {
    QString fullPath = QString(_serverConfigs["getArtistAlbum"][_serverIndices.value("getArtistAlbum")].URL()+"/artist/album");
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "id", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("id")).append(querySuffix).append(QUrl::toPercentEncoding(::MelodixAPI::toStringValue(id)));
    }
    if (limit.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "limit", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("limit")).append(querySuffix).append(QUrl::toPercentEncoding(::MelodixAPI::toStringValue(limit.value())));
    }
    MDHttpRequestWorker *worker = new MDHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    MDHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &MDHttpRequestWorker::on_execution_finished, this, &MDClientApi::getArtistAlbumCallback);
    connect(this, &MDClientApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<MDHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void MDClientApi::getArtistAlbumCallback(MDHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    MDGetArtistAlbum_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getArtistAlbumSignal(output);
        emit getArtistAlbumSignalFull(worker, output);
    } else {
        emit getArtistAlbumSignalE(output, error_type, error_str);
        emit getArtistAlbumSignalEFull(worker, error_type, error_str);
    }
}

void MDClientApi::getArtistDetail(const QString &id) {
    QString fullPath = QString(_serverConfigs["getArtistDetail"][_serverIndices.value("getArtistDetail")].URL()+"/artist/detail");
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "id", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("id")).append(querySuffix).append(QUrl::toPercentEncoding(::MelodixAPI::toStringValue(id)));
    }
    MDHttpRequestWorker *worker = new MDHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    MDHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &MDHttpRequestWorker::on_execution_finished, this, &MDClientApi::getArtistDetailCallback);
    connect(this, &MDClientApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<MDHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void MDClientApi::getArtistDetailCallback(MDHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    MDGetArtistDetail_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getArtistDetailSignal(output);
        emit getArtistDetailSignalFull(worker, output);
    } else {
        emit getArtistDetailSignalE(output, error_type, error_str);
        emit getArtistDetailSignalEFull(worker, error_type, error_str);
    }
}

void MDClientApi::getArtistMv(const QString &id) {
    QString fullPath = QString(_serverConfigs["getArtistMv"][_serverIndices.value("getArtistMv")].URL()+"/artist/mv");
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "id", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("id")).append(querySuffix).append(QUrl::toPercentEncoding(::MelodixAPI::toStringValue(id)));
    }
    MDHttpRequestWorker *worker = new MDHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    MDHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &MDHttpRequestWorker::on_execution_finished, this, &MDClientApi::getArtistMvCallback);
    connect(this, &MDClientApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<MDHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void MDClientApi::getArtistMvCallback(MDHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    MDGetArtistMv_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getArtistMvSignal(output);
        emit getArtistMvSignalFull(worker, output);
    } else {
        emit getArtistMvSignalE(output, error_type, error_str);
        emit getArtistMvSignalEFull(worker, error_type, error_str);
    }
}

void MDClientApi::getArtistSingle(const QString &id) {
    QString fullPath = QString(_serverConfigs["getArtistSingle"][_serverIndices.value("getArtistSingle")].URL()+"/artists");
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "id", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("id")).append(querySuffix).append(QUrl::toPercentEncoding(::MelodixAPI::toStringValue(id)));
    }
    MDHttpRequestWorker *worker = new MDHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    MDHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &MDHttpRequestWorker::on_execution_finished, this, &MDClientApi::getArtistSingleCallback);
    connect(this, &MDClientApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<MDHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void MDClientApi::getArtistSingleCallback(MDHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    MDGetArtistSingle_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getArtistSingleSignal(output);
        emit getArtistSingleSignalFull(worker, output);
    } else {
        emit getArtistSingleSignalE(output, error_type, error_str);
        emit getArtistSingleSignalEFull(worker, error_type, error_str);
    }
}

void MDClientApi::getArtistSublist(const QString &timestamp) {
    QString fullPath = QString(_serverConfigs["getArtistSublist"][_serverIndices.value("getArtistSublist")].URL()+"/artist/sublist");
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "timestamp", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("timestamp")).append(querySuffix).append(QUrl::toPercentEncoding(::MelodixAPI::toStringValue(timestamp)));
    }
    MDHttpRequestWorker *worker = new MDHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    MDHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &MDHttpRequestWorker::on_execution_finished, this, &MDClientApi::getArtistSublistCallback);
    connect(this, &MDClientApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<MDHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void MDClientApi::getArtistSublistCallback(MDHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    MDGetArtistSublist_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getArtistSublistSignal(output);
        emit getArtistSublistSignalFull(worker, output);
    } else {
        emit getArtistSublistSignalE(output, error_type, error_str);
        emit getArtistSublistSignalEFull(worker, error_type, error_str);
    }
}

void MDClientApi::getHotComment(const QString &id, const QString &type) {
    QString fullPath = QString(_serverConfigs["getHotComment"][_serverIndices.value("getHotComment")].URL()+"/comment/hot");
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "id", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("id")).append(querySuffix).append(QUrl::toPercentEncoding(::MelodixAPI::toStringValue(id)));
    }
    
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "type", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("type")).append(querySuffix).append(QUrl::toPercentEncoding(::MelodixAPI::toStringValue(type)));
    }
    MDHttpRequestWorker *worker = new MDHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    MDHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &MDHttpRequestWorker::on_execution_finished, this, &MDClientApi::getHotCommentCallback);
    connect(this, &MDClientApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<MDHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void MDClientApi::getHotCommentCallback(MDHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    MDGetHotComment_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getHotCommentSignal(output);
        emit getHotCommentSignalFull(worker, output);
    } else {
        emit getHotCommentSignalE(output, error_type, error_str);
        emit getHotCommentSignalEFull(worker, error_type, error_str);
    }
}

void MDClientApi::getLikeSongId(const QString &uid) {
    QString fullPath = QString(_serverConfigs["getLikeSongId"][_serverIndices.value("getLikeSongId")].URL()+"/likelist");
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "uid", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("uid")).append(querySuffix).append(QUrl::toPercentEncoding(::MelodixAPI::toStringValue(uid)));
    }
    MDHttpRequestWorker *worker = new MDHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    MDHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &MDHttpRequestWorker::on_execution_finished, this, &MDClientApi::getLikeSongIdCallback);
    connect(this, &MDClientApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<MDHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void MDClientApi::getLikeSongIdCallback(MDHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    MDGetLikeSongId_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getLikeSongIdSignal(output);
        emit getLikeSongIdSignalFull(worker, output);
    } else {
        emit getLikeSongIdSignalE(output, error_type, error_str);
        emit getLikeSongIdSignalEFull(worker, error_type, error_str);
    }
}

void MDClientApi::getLoginStatus(const QString &timestamp) {
    QString fullPath = QString(_serverConfigs["getLoginStatus"][_serverIndices.value("getLoginStatus")].URL()+"/login/status");
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "timestamp", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("timestamp")).append(querySuffix).append(QUrl::toPercentEncoding(::MelodixAPI::toStringValue(timestamp)));
    }
    MDHttpRequestWorker *worker = new MDHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    MDHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &MDHttpRequestWorker::on_execution_finished, this, &MDClientApi::getLoginStatusCallback);
    connect(this, &MDClientApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<MDHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void MDClientApi::getLoginStatusCallback(MDHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    MDGetLoginStatus_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getLoginStatusSignal(output);
        emit getLoginStatusSignalFull(worker, output);
    } else {
        emit getLoginStatusSignalE(output, error_type, error_str);
        emit getLoginStatusSignalEFull(worker, error_type, error_str);
    }
}

void MDClientApi::getLyric(const QString &id) {
    QString fullPath = QString(_serverConfigs["getLyric"][_serverIndices.value("getLyric")].URL()+"/lyric");
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "id", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("id")).append(querySuffix).append(QUrl::toPercentEncoding(::MelodixAPI::toStringValue(id)));
    }
    MDHttpRequestWorker *worker = new MDHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    MDHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &MDHttpRequestWorker::on_execution_finished, this, &MDClientApi::getLyricCallback);
    connect(this, &MDClientApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<MDHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void MDClientApi::getLyricCallback(MDHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    MDGetLyric_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getLyricSignal(output);
        emit getLyricSignalFull(worker, output);
    } else {
        emit getLyricSignalE(output, error_type, error_str);
        emit getLyricSignalEFull(worker, error_type, error_str);
    }
}

void MDClientApi::getMvDetail(const QString &mvid) {
    QString fullPath = QString(_serverConfigs["getMvDetail"][_serverIndices.value("getMvDetail")].URL()+"/mv/detail");
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "mvid", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("mvid")).append(querySuffix).append(QUrl::toPercentEncoding(::MelodixAPI::toStringValue(mvid)));
    }
    MDHttpRequestWorker *worker = new MDHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    MDHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &MDHttpRequestWorker::on_execution_finished, this, &MDClientApi::getMvDetailCallback);
    connect(this, &MDClientApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<MDHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void MDClientApi::getMvDetailCallback(MDHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    MDGetMvDetail_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getMvDetailSignal(output);
        emit getMvDetailSignalFull(worker, output);
    } else {
        emit getMvDetailSignalE(output, error_type, error_str);
        emit getMvDetailSignalEFull(worker, error_type, error_str);
    }
}

void MDClientApi::getMvSublist(const QString &timestamp) {
    QString fullPath = QString(_serverConfigs["getMvSublist"][_serverIndices.value("getMvSublist")].URL()+"/mv/sublist");
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "timestamp", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("timestamp")).append(querySuffix).append(QUrl::toPercentEncoding(::MelodixAPI::toStringValue(timestamp)));
    }
    MDHttpRequestWorker *worker = new MDHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    MDHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &MDHttpRequestWorker::on_execution_finished, this, &MDClientApi::getMvSublistCallback);
    connect(this, &MDClientApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<MDHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void MDClientApi::getMvSublistCallback(MDHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    MDGetMvSublist_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getMvSublistSignal(output);
        emit getMvSublistSignalFull(worker, output);
    } else {
        emit getMvSublistSignalE(output, error_type, error_str);
        emit getMvSublistSignalEFull(worker, error_type, error_str);
    }
}

void MDClientApi::getMvUrl(const QString &id, const ::MelodixAPI::OptionalParam<QString> &r) {
    QString fullPath = QString(_serverConfigs["getMvUrl"][_serverIndices.value("getMvUrl")].URL()+"/mv/url");
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "id", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("id")).append(querySuffix).append(QUrl::toPercentEncoding(::MelodixAPI::toStringValue(id)));
    }
    if (r.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "r", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("r")).append(querySuffix).append(QUrl::toPercentEncoding(::MelodixAPI::toStringValue(r.value())));
    }
    MDHttpRequestWorker *worker = new MDHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    MDHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &MDHttpRequestWorker::on_execution_finished, this, &MDClientApi::getMvUrlCallback);
    connect(this, &MDClientApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<MDHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void MDClientApi::getMvUrlCallback(MDHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    MDGetMvUrl_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getMvUrlSignal(output);
        emit getMvUrlSignalFull(worker, output);
    } else {
        emit getMvUrlSignalE(output, error_type, error_str);
        emit getMvUrlSignalEFull(worker, error_type, error_str);
    }
}

void MDClientApi::getPlaylistDetail(const QString &id) {
    QString fullPath = QString(_serverConfigs["getPlaylistDetail"][_serverIndices.value("getPlaylistDetail")].URL()+"/playlist/detail");
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "id", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("id")).append(querySuffix).append(QUrl::toPercentEncoding(::MelodixAPI::toStringValue(id)));
    }
    MDHttpRequestWorker *worker = new MDHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    MDHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &MDHttpRequestWorker::on_execution_finished, this, &MDClientApi::getPlaylistDetailCallback);
    connect(this, &MDClientApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<MDHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void MDClientApi::getPlaylistDetailCallback(MDHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    MDGetPlaylistDetail_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getPlaylistDetailSignal(output);
        emit getPlaylistDetailSignalFull(worker, output);
    } else {
        emit getPlaylistDetailSignalE(output, error_type, error_str);
        emit getPlaylistDetailSignalEFull(worker, error_type, error_str);
    }
}

void MDClientApi::getPlaylistTrackAll(const QString &id, const ::MelodixAPI::OptionalParam<QString> &limit, const ::MelodixAPI::OptionalParam<QString> &offset) {
    QString fullPath = QString(_serverConfigs["getPlaylistTrackAll"][_serverIndices.value("getPlaylistTrackAll")].URL()+"/playlist/track/all");
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "id", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("id")).append(querySuffix).append(QUrl::toPercentEncoding(::MelodixAPI::toStringValue(id)));
    }
    if (limit.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "limit", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("limit")).append(querySuffix).append(QUrl::toPercentEncoding(::MelodixAPI::toStringValue(limit.value())));
    }
    if (offset.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "offset", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("offset")).append(querySuffix).append(QUrl::toPercentEncoding(::MelodixAPI::toStringValue(offset.value())));
    }
    MDHttpRequestWorker *worker = new MDHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    MDHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &MDHttpRequestWorker::on_execution_finished, this, &MDClientApi::getPlaylistTrackAllCallback);
    connect(this, &MDClientApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<MDHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void MDClientApi::getPlaylistTrackAllCallback(MDHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    MDGetPlaylistTrackAll_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getPlaylistTrackAllSignal(output);
        emit getPlaylistTrackAllSignalFull(worker, output);
    } else {
        emit getPlaylistTrackAllSignalE(output, error_type, error_str);
        emit getPlaylistTrackAllSignalEFull(worker, error_type, error_str);
    }
}

void MDClientApi::getPurchasedAlbum(const ::MelodixAPI::OptionalParam<QString> &limit) {
    QString fullPath = QString(_serverConfigs["getPurchasedAlbum"][_serverIndices.value("getPurchasedAlbum")].URL()+"/digitalAlbum/purchased");
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (limit.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "limit", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("limit")).append(querySuffix).append(QUrl::toPercentEncoding(::MelodixAPI::toStringValue(limit.value())));
    }
    MDHttpRequestWorker *worker = new MDHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    MDHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &MDHttpRequestWorker::on_execution_finished, this, &MDClientApi::getPurchasedAlbumCallback);
    connect(this, &MDClientApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<MDHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void MDClientApi::getPurchasedAlbumCallback(MDHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    MDGetPurchasedAlbum_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getPurchasedAlbumSignal(output);
        emit getPurchasedAlbumSignalFull(worker, output);
    } else {
        emit getPurchasedAlbumSignalE(output, error_type, error_str);
        emit getPurchasedAlbumSignalEFull(worker, error_type, error_str);
    }
}

void MDClientApi::getQrKey() {
    QString fullPath = QString(_serverConfigs["getQrKey"][_serverIndices.value("getQrKey")].URL()+"/login/qr/key");
    
    MDHttpRequestWorker *worker = new MDHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    MDHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &MDHttpRequestWorker::on_execution_finished, this, &MDClientApi::getQrKeyCallback);
    connect(this, &MDClientApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<MDHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void MDClientApi::getQrKeyCallback(MDHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    MDGetQrKey_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getQrKeySignal(output);
        emit getQrKeySignalFull(worker, output);
    } else {
        emit getQrKeySignalE(output, error_type, error_str);
        emit getQrKeySignalEFull(worker, error_type, error_str);
    }
}

void MDClientApi::getRecommendedMv() {
    QString fullPath = QString(_serverConfigs["getRecommendedMv"][_serverIndices.value("getRecommendedMv")].URL()+"/personalized/mv");
    
    MDHttpRequestWorker *worker = new MDHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    MDHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &MDHttpRequestWorker::on_execution_finished, this, &MDClientApi::getRecommendedMvCallback);
    connect(this, &MDClientApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<MDHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void MDClientApi::getRecommendedMvCallback(MDHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    MDGetRecommendedMv_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getRecommendedMvSignal(output);
        emit getRecommendedMvSignalFull(worker, output);
    } else {
        emit getRecommendedMvSignalE(output, error_type, error_str);
        emit getRecommendedMvSignalEFull(worker, error_type, error_str);
    }
}

void MDClientApi::getRecommendedNewSongs(const ::MelodixAPI::OptionalParam<QString> &limit) {
    QString fullPath = QString(_serverConfigs["getRecommendedNewSongs"][_serverIndices.value("getRecommendedNewSongs")].URL()+"/personalized/newsong");
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (limit.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "limit", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("limit")).append(querySuffix).append(QUrl::toPercentEncoding(::MelodixAPI::toStringValue(limit.value())));
    }
    MDHttpRequestWorker *worker = new MDHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    MDHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &MDHttpRequestWorker::on_execution_finished, this, &MDClientApi::getRecommendedNewSongsCallback);
    connect(this, &MDClientApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<MDHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void MDClientApi::getRecommendedNewSongsCallback(MDHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    MDGetRecommendedNewSongs_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getRecommendedNewSongsSignal(output);
        emit getRecommendedNewSongsSignalFull(worker, output);
    } else {
        emit getRecommendedNewSongsSignalE(output, error_type, error_str);
        emit getRecommendedNewSongsSignalEFull(worker, error_type, error_str);
    }
}

void MDClientApi::getRecommendedPlaylist(const ::MelodixAPI::OptionalParam<QString> &limit) {
    QString fullPath = QString(_serverConfigs["getRecommendedPlaylist"][_serverIndices.value("getRecommendedPlaylist")].URL()+"/personalized");
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (limit.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "limit", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("limit")).append(querySuffix).append(QUrl::toPercentEncoding(::MelodixAPI::toStringValue(limit.value())));
    }
    MDHttpRequestWorker *worker = new MDHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    MDHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &MDHttpRequestWorker::on_execution_finished, this, &MDClientApi::getRecommendedPlaylistCallback);
    connect(this, &MDClientApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<MDHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void MDClientApi::getRecommendedPlaylistCallback(MDHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    MDGetRecommendedPlaylist_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getRecommendedPlaylistSignal(output);
        emit getRecommendedPlaylistSignalFull(worker, output);
    } else {
        emit getRecommendedPlaylistSignalE(output, error_type, error_str);
        emit getRecommendedPlaylistSignalEFull(worker, error_type, error_str);
    }
}

void MDClientApi::getSimiMv(const QString &mvid) {
    QString fullPath = QString(_serverConfigs["getSimiMv"][_serverIndices.value("getSimiMv")].URL()+"/simi/mv");
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "mvid", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("mvid")).append(querySuffix).append(QUrl::toPercentEncoding(::MelodixAPI::toStringValue(mvid)));
    }
    MDHttpRequestWorker *worker = new MDHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    MDHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &MDHttpRequestWorker::on_execution_finished, this, &MDClientApi::getSimiMvCallback);
    connect(this, &MDClientApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<MDHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void MDClientApi::getSimiMvCallback(MDHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    MDGetSimiMv_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getSimiMvSignal(output);
        emit getSimiMvSignalFull(worker, output);
    } else {
        emit getSimiMvSignalE(output, error_type, error_str);
        emit getSimiMvSignalEFull(worker, error_type, error_str);
    }
}

void MDClientApi::getSongDetail(const QString &ids) {
    QString fullPath = QString(_serverConfigs["getSongDetail"][_serverIndices.value("getSongDetail")].URL()+"/song/detail");
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "ids", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("ids")).append(querySuffix).append(QUrl::toPercentEncoding(::MelodixAPI::toStringValue(ids)));
    }
    MDHttpRequestWorker *worker = new MDHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    MDHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &MDHttpRequestWorker::on_execution_finished, this, &MDClientApi::getSongDetailCallback);
    connect(this, &MDClientApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<MDHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void MDClientApi::getSongDetailCallback(MDHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    MDGetSongDetail_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getSongDetailSignal(output);
        emit getSongDetailSignalFull(worker, output);
    } else {
        emit getSongDetailSignalE(output, error_type, error_str);
        emit getSongDetailSignalEFull(worker, error_type, error_str);
    }
}

void MDClientApi::getSongUrl(const QString &id) {
    QString fullPath = QString(_serverConfigs["getSongUrl"][_serverIndices.value("getSongUrl")].URL()+"/song/url");
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "id", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("id")).append(querySuffix).append(QUrl::toPercentEncoding(::MelodixAPI::toStringValue(id)));
    }
    MDHttpRequestWorker *worker = new MDHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    MDHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &MDHttpRequestWorker::on_execution_finished, this, &MDClientApi::getSongUrlCallback);
    connect(this, &MDClientApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<MDHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void MDClientApi::getSongUrlCallback(MDHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    MDGetSongUrl_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getSongUrlSignal(output);
        emit getSongUrlSignalFull(worker, output);
    } else {
        emit getSongUrlSignalE(output, error_type, error_str);
        emit getSongUrlSignalEFull(worker, error_type, error_str);
    }
}

void MDClientApi::getTopArtists() {
    QString fullPath = QString(_serverConfigs["getTopArtists"][_serverIndices.value("getTopArtists")].URL()+"/top/artists");
    
    MDHttpRequestWorker *worker = new MDHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    MDHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &MDHttpRequestWorker::on_execution_finished, this, &MDClientApi::getTopArtistsCallback);
    connect(this, &MDClientApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<MDHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void MDClientApi::getTopArtistsCallback(MDHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    MDGetTopArtists_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getTopArtistsSignal(output);
        emit getTopArtistsSignalFull(worker, output);
    } else {
        emit getTopArtistsSignalE(output, error_type, error_str);
        emit getTopArtistsSignalEFull(worker, error_type, error_str);
    }
}

void MDClientApi::getTopPlaylist(const QString &cat, const ::MelodixAPI::OptionalParam<QString> &order, const ::MelodixAPI::OptionalParam<QString> &limit, const ::MelodixAPI::OptionalParam<QString> &offset) {
    QString fullPath = QString(_serverConfigs["getTopPlaylist"][_serverIndices.value("getTopPlaylist")].URL()+"/top/playlist");
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "cat", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("cat")).append(querySuffix).append(QUrl::toPercentEncoding(::MelodixAPI::toStringValue(cat)));
    }
    if (order.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "order", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("order")).append(querySuffix).append(QUrl::toPercentEncoding(::MelodixAPI::toStringValue(order.value())));
    }
    if (limit.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "limit", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("limit")).append(querySuffix).append(QUrl::toPercentEncoding(::MelodixAPI::toStringValue(limit.value())));
    }
    if (offset.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "offset", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("offset")).append(querySuffix).append(QUrl::toPercentEncoding(::MelodixAPI::toStringValue(offset.value())));
    }
    MDHttpRequestWorker *worker = new MDHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    MDHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &MDHttpRequestWorker::on_execution_finished, this, &MDClientApi::getTopPlaylistCallback);
    connect(this, &MDClientApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<MDHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void MDClientApi::getTopPlaylistCallback(MDHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    MDGetTopPlaylist_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getTopPlaylistSignal(output);
        emit getTopPlaylistSignalFull(worker, output);
    } else {
        emit getTopPlaylistSignalE(output, error_type, error_str);
        emit getTopPlaylistSignalEFull(worker, error_type, error_str);
    }
}

void MDClientApi::getUserPlaylist(const QString &uid) {
    QString fullPath = QString(_serverConfigs["getUserPlaylist"][_serverIndices.value("getUserPlaylist")].URL()+"/user/playlist");
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "uid", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("uid")).append(querySuffix).append(QUrl::toPercentEncoding(::MelodixAPI::toStringValue(uid)));
    }
    MDHttpRequestWorker *worker = new MDHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    MDHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &MDHttpRequestWorker::on_execution_finished, this, &MDClientApi::getUserPlaylistCallback);
    connect(this, &MDClientApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<MDHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void MDClientApi::getUserPlaylistCallback(MDHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    MDGetUserPlaylist_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getUserPlaylistSignal(output);
        emit getUserPlaylistSignalFull(worker, output);
    } else {
        emit getUserPlaylistSignalE(output, error_type, error_str);
        emit getUserPlaylistSignalEFull(worker, error_type, error_str);
    }
}

void MDClientApi::likeMusic(const QString &id, const QString &like, const QString &timestamp) {
    QString fullPath = QString(_serverConfigs["likeMusic"][_serverIndices.value("likeMusic")].URL()+"/like");
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "id", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("id")).append(querySuffix).append(QUrl::toPercentEncoding(::MelodixAPI::toStringValue(id)));
    }
    
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "like", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("like")).append(querySuffix).append(QUrl::toPercentEncoding(::MelodixAPI::toStringValue(like)));
    }
    
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "timestamp", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("timestamp")).append(querySuffix).append(QUrl::toPercentEncoding(::MelodixAPI::toStringValue(timestamp)));
    }
    MDHttpRequestWorker *worker = new MDHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    MDHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &MDHttpRequestWorker::on_execution_finished, this, &MDClientApi::likeMusicCallback);
    connect(this, &MDClientApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<MDHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void MDClientApi::likeMusicCallback(MDHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    MDLikeMusic_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit likeMusicSignal(output);
        emit likeMusicSignalFull(worker, output);
    } else {
        emit likeMusicSignalE(output, error_type, error_str);
        emit likeMusicSignalEFull(worker, error_type, error_str);
    }
}

void MDClientApi::qrCheck(const QString &key, const ::MelodixAPI::OptionalParam<MDObject> &body) {
    QString fullPath = QString(_serverConfigs["qrCheck"][_serverIndices.value("qrCheck")].URL()+"/login/qr/check");
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "key", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("key")).append(querySuffix).append(QUrl::toPercentEncoding(::MelodixAPI::toStringValue(key)));
    }
    MDHttpRequestWorker *worker = new MDHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    MDHttpRequestInput input(fullPath, "GET");

    if (body.hasValue()){

        
        QByteArray output = body.value().asJson().toUtf8();
        input.request_body.append(output);
    }
#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &MDHttpRequestWorker::on_execution_finished, this, &MDClientApi::qrCheckCallback);
    connect(this, &MDClientApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<MDHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void MDClientApi::qrCheckCallback(MDHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    MDQrCheck_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit qrCheckSignal(output);
        emit qrCheckSignalFull(worker, output);
    } else {
        emit qrCheckSignalE(output, error_type, error_str);
        emit qrCheckSignalEFull(worker, error_type, error_str);
    }
}

void MDClientApi::qrCreate(const QString &key, const ::MelodixAPI::OptionalParam<double> &qrimg) {
    QString fullPath = QString(_serverConfigs["qrCreate"][_serverIndices.value("qrCreate")].URL()+"/login/qr/create");
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "key", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("key")).append(querySuffix).append(QUrl::toPercentEncoding(::MelodixAPI::toStringValue(key)));
    }
    if (qrimg.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "qrimg", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("qrimg")).append(querySuffix).append(QUrl::toPercentEncoding(::MelodixAPI::toStringValue(qrimg.value())));
    }
    MDHttpRequestWorker *worker = new MDHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    MDHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &MDHttpRequestWorker::on_execution_finished, this, &MDClientApi::qrCreateCallback);
    connect(this, &MDClientApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<MDHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void MDClientApi::qrCreateCallback(MDHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    MDQrCreate_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit qrCreateSignal(output);
        emit qrCreateSignalFull(worker, output);
    } else {
        emit qrCreateSignalE(output, error_type, error_str);
        emit qrCreateSignalEFull(worker, error_type, error_str);
    }
}

void MDClientApi::search(const QString &keywords, const ::MelodixAPI::OptionalParam<QString> &limit, const ::MelodixAPI::OptionalParam<QString> &offset, const ::MelodixAPI::OptionalParam<QString> &type) {
    QString fullPath = QString(_serverConfigs["search"][_serverIndices.value("search")].URL()+"/cloudsearch");
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "keywords", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("keywords")).append(querySuffix).append(QUrl::toPercentEncoding(::MelodixAPI::toStringValue(keywords)));
    }
    if (limit.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "limit", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("limit")).append(querySuffix).append(QUrl::toPercentEncoding(::MelodixAPI::toStringValue(limit.value())));
    }
    if (offset.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "offset", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("offset")).append(querySuffix).append(QUrl::toPercentEncoding(::MelodixAPI::toStringValue(offset.value())));
    }
    if (type.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "type", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("type")).append(querySuffix).append(QUrl::toPercentEncoding(::MelodixAPI::toStringValue(type.value())));
    }
    MDHttpRequestWorker *worker = new MDHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    MDHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &MDHttpRequestWorker::on_execution_finished, this, &MDClientApi::searchCallback);
    connect(this, &MDClientApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<MDHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void MDClientApi::searchCallback(MDHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    MDSearch_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit searchSignal(output);
        emit searchSignalFull(worker, output);
    } else {
        emit searchSignalE(output, error_type, error_str);
        emit searchSignalEFull(worker, error_type, error_str);
    }
}

void MDClientApi::sendCaptcha(const QString &phone, const ::MelodixAPI::OptionalParam<QString> &ctcode) {
    QString fullPath = QString(_serverConfigs["sendCaptcha"][_serverIndices.value("sendCaptcha")].URL()+"/captcha/sent");
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "phone", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("phone")).append(querySuffix).append(QUrl::toPercentEncoding(::MelodixAPI::toStringValue(phone)));
    }
    if (ctcode.hasValue())
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "ctcode", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("ctcode")).append(querySuffix).append(QUrl::toPercentEncoding(::MelodixAPI::toStringValue(ctcode.value())));
    }
    MDHttpRequestWorker *worker = new MDHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    MDHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &MDHttpRequestWorker::on_execution_finished, this, &MDClientApi::sendCaptchaCallback);
    connect(this, &MDClientApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<MDHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void MDClientApi::sendCaptchaCallback(MDHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    MDSendCaptcha_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit sendCaptchaSignal(output);
        emit sendCaptchaSignalFull(worker, output);
    } else {
        emit sendCaptchaSignalE(output, error_type, error_str);
        emit sendCaptchaSignalEFull(worker, error_type, error_str);
    }
}

void MDClientApi::verifyCaptcha(const QString &phone, const QString &captcha) {
    QString fullPath = QString(_serverConfigs["verifyCaptcha"][_serverIndices.value("verifyCaptcha")].URL()+"/captcha/verify");
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "phone", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("phone")).append(querySuffix).append(QUrl::toPercentEncoding(::MelodixAPI::toStringValue(phone)));
    }
    
    {
        queryStyle = "";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "captcha", false);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("captcha")).append(querySuffix).append(QUrl::toPercentEncoding(::MelodixAPI::toStringValue(captcha)));
    }
    MDHttpRequestWorker *worker = new MDHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    MDHttpRequestInput input(fullPath, "GET");


#if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }
#else
    for (auto key : _defaultHeaders.keys()) {
        input.headers.insert(key, _defaultHeaders[key]);
    }
#endif

    connect(worker, &MDHttpRequestWorker::on_execution_finished, this, &MDClientApi::verifyCaptchaCallback);
    connect(this, &MDClientApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<MDHttpRequestWorker*>().count() == 0) {
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void MDClientApi::verifyCaptchaCallback(MDHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    MDSendCaptcha_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit verifyCaptchaSignal(output);
        emit verifyCaptchaSignalFull(worker, output);
    } else {
        emit verifyCaptchaSignalE(output, error_type, error_str);
        emit verifyCaptchaSignalEFull(worker, error_type, error_str);
    }
}

void MDClientApi::tokenAvailable(){

    oauthToken token;
    switch (_OauthMethod) {
    case 1: //implicit flow
        token = _implicitFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _implicitFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 2: //authorization flow
        token = _authFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _authFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 3: //client credentials flow
        token = _credentialFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 4: //resource owner password flow
        token = _passwordFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    default:
        qDebug() << "No Oauth method set!";
        break;
    }
}
} // namespace MelodixAPI
